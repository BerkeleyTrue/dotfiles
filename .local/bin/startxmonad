#!/bin/bash

set -eu

LOG_DIR="$HOME/.local/share/x11"
LOG_FILE="$LOG_DIR/x11-session.log"
STARTUP_LOG="$LOG_DIR/startup.log"

__log() {
    echo "$(date +%H:%M:%S) startx: $*"
}

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# Clear old logs
echo "" > "$LOG_FILE"
echo "" > "$STARTUP_LOG"

# Redirect output to logs
exec 1> >(tee -a "$STARTUP_LOG")
exec 2> >(tee -a "$STARTUP_LOG" >&2)

__log "starting"

# Export essential environment variables
export DESKTOP_SESSION=xmonad
export XDG_CURRENT_DESKTOP=XMonad
export XDG_SESSION_DESKTOP=XMonad
export XDG_SESSION_TYPE=x11

__setup_environment() {
    __log "setting up environment"
    
    # Ensure systemd user session is available
    if ! systemctl --user status >/dev/null 2>&1; then
        __log "ERROR: user session not available"
        exit 1
    fi
    
    # Import environment variables for systemd
    if command -v dbus-update-activation-environment >/dev/null; then
        dbus-update-activation-environment \
            XDG_CURRENT_DESKTOP \
            XDG_SESSION_DESKTOP \
            XDG_SESSION_TYPE \
            DESKTOP_SESSION
    fi
}

__start_x11_session() {
    __log "starting session target"
    
    # Start the X11 session hierarchy
    if ! systemctl --user start x11-session.target; then
        __log "ERROR: Failed to start "
        return 1
    fi
    
    # Wait for XMonad to be ready
    __log "waiting for XMonad to start"
    timeout 30 bash -c 'while ! systemctl --user is-active xmonad.service >/dev/null 2>&1; do sleep 0.5; done' || {
        __log "ERROR: xmonad failed to start"
        return 1
    }
    
    __log "session started"
}

__monitor_session() {
    __log "monitoring"
    
    # Monitor the session - exit when XMonad stops
    while systemctl --user is-active xmonad.service >/dev/null 2>&1; do
        sleep 2
    done
    
    __log "xmonad session ended"
}

__cleanup_session() {
    __log "cleaning up"
    
    # Stop the session gracefully
    systemctl --user stop x11-session.target || true
    
    # Wait for services to stop
    timeout 10 bash -c 'while systemctl --user --no-legend --state=deactivating list-units | grep -q .; do sleep 0.1; done' || true
    
    # Clear environment variables
    systemctl --user unset-environment \
        DISPLAY \
        XAUTHORITY \
        XDG_SESSION_TYPE \
        XDG_CURRENT_DESKTOP \
        XDG_SESSION_DESKTOP \
        DESKTOP_SESSION || true
    
    __log "X11 session cleanup complete"
}

__main() {
    # Only run in tty1
    if [[ "$(tty)" != "/dev/tty1" ]]; then
        __log "X11 session must be started from tty1"
        exit 1
    fi
    
    # Check if X is already running
    if pgrep -x Xorg >/dev/null; then
        __log "ERROR: X server is already running"
        exit 1
    fi
    
    # Ensure cleanup on exit
    trap __cleanup_session EXIT INT TERM
    
    # Setup and start session
    __setup_environment
    
    # Start X server with our xinitrc equivalent
    __log "starting X"
    # startx with custom xinitrc
    # On display :0, virtual terminal 1
    startx $HOME/.config/x11/xinitrc &
    # capture the PID
    STARTX_PID=$!
    
    # wait for x server to be ready
    # x0 socket appears when X server is ready to accept connections
    timeout 10 bash -c 'while [ ! -S /tmp/.X11-unix/X0 ]; do sleep 0.1; done' || {
        __log "ERROR: X server failed to start"
        exit 1
    }
    
    # Start systemd session management
    __start_x11_session || {
        __log "ERROR: Failed to start systemd session"
        kill $STARTX_PID 2>/dev/null || true
        exit 1
    }
    
    # Monitor the session
    __monitor_session
    
    # Wait for startx to finish
    wait $STARTX_PID || true
    
    __log "X11 session ended normally"
}

__main "$@"
