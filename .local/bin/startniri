#!/bin/bash

set -eu

LOG_DIR="$HOME/.local/share/niri"
LOG_FILE="$LOG_DIR/session.log"
STARTUP_LOG="$LOG_DIR/startup.log"

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# Clear old logs
echo "" >"$LOG_FILE"
echo "" >"$STARTUP_LOG"
# Redirect output to logs
exec 1> >(tee -a "$STARTUP_LOG")
exec 2> >(tee -a "$STARTUP_LOG" >&2)

__log() {
	echo "$(date +%H:%M:%S) startniri: $*"
}

__setup_env() {
	# Ensure systemd user session is available
	if ! systemctl --user status >/dev/null 2>&1; then
		__log "ERROR: user session not available"
		exit 1
	fi

	# Reset failed state of all user units.
	systemctl --user reset-failed
	# Import the login manager environment.
	systemctl --user import-environment

	# DBus activation environment is independent from systemd. While most of
	# dbus-activated services are already using `SystemdService` directive, some
	# still don't and thus we should set the dbus environment with a separate
	# command.
	if hash dbus-update-activation-environment 2>/dev/null; then
		dbus-update-activation-environment --all
	fi
}

__cleanup() {
	# Force stop of graphical-session.target.
	systemctl --user start --job-mode=replace-irreversibly shutdown-graphical.target
	# Unset environment that we've set.
	systemctl --user unset-environment WAYLAND_DISPLAY DISPLAY XDG_SESSION_TYPE XDG_CURRENT_DESKTOP NIRI_SOCKET
}

__main() {
	# Only run in tty1
	if [[ "$(tty)" != "/dev/tty1" ]]; then
		__log "ERROR: Niri session must be started from tty1"
		exit 1
	fi

	if systemctl --user -q is-active niri.service; then
		__log 'ERROR: A niri session is already running.'
		exit 1
	fi

	# Ensure cleanup on exit
	trap __cleanup EXIT INT TERM

	__setup_env

	__log "Starting niri"

	# Start niri and wait for it to terminate.
	systemctl --user --wait start niri.target

	__log "goodbye, beautiful"
	__cleanup
}

__main "$@"
