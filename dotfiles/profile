# Add vi mappings to bash
set -o vi

export PATH=/usr/local/bin:$PATH

# Point to java 7
export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home"

# Adds mongoDB binaries to path
export PATH=$PATH:~/mongodb/bin

# Add RVM to PATH for scripting
export PATH=$PATH:$HOME/.rvm/bin

#Go lang
export GOROOT=/usr/local/go
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin

#Heroku Toolbelt
export PATH=$PATH:/usr/local/heroku/bin

#PostgressApp commands
export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.3/bin

# Make neovim the default editor
export EDITOR=nvim
export VISUAL=$EDITOR

# Add lang settings for fonts to work properly
export LANG=en_US.UTF-8
export LC_COLLATE=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8
export LC_MESSAGES=en_US.UTF-8
export LC_MONETARY=en_US.UTF-8
export LC_NUMERIC=en_US.UTF-8
export LC_TIME=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Bash helper alias
## Starts MongoDB server
alias ..='cd ..'
alias ll='ls -aFlh'
alias v='nvim'
alias vi='nvim'
alias vim='nvim'
alias tmux="TERM=screen-256color-bce tmux -2"
## Will make parent directories if they don't exist
## Also verbose
alias mkdir="mkdir -pv"
alias whatismyip="curl http://ipecho.net/plain; echo"
## Make file executable
alias chmodx='chmod 755'
## Make file read/write-able
alias chmodrw='chmod 644'
## print bash function declaration in console
## Used to make sure profile changes are reflecting
alias echodec='declare -f'

#quick edits
alias vprofile='nvim ~/.profile'
alias sprofile='source ~/.profile'
alias vvimrc='nvim ~/.vimrc'
alias vneo='nvim ~/.config/nvim/init.vim'
alias vlint='nvim ~/.eslintrc'
alias vhyper='nvim ~/.hyper.js'

#node aliases
alias :mongo='mongod --dbpath ~/data/db'
alias npmig='sudo npm install -g'
alias npmug='sudo npm uninstall -g'
alias npmid='npm install --save-dev'
alias npmis='npm install --save'
alias npms='npm run start'
alias npmt='npm run test'
alias npml='npm run lint'

#quickmoves
alias cdnode='cd ~/node'
alias cdf='cd ~/node/freecodecamp/actual'
alias cdrt='cd ~/node/react'
alias cdrdx='cd ~/node/redux'
alias cdrwr='cd ~/node/rwr'
alias cdvim='cd ~/.vim'

#git aliases
alias gstat='git status'
alias gfetch='git fetch'
alias gpush='git push'
alias gpushntrack='git push -u'
alias gadd='git add'
alias gdiff='git diff'
alias gcom='git cz'
alias gamend='git commit --amend'
alias glog='git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate'
alias glognum='git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --numstat'
alias gco='git checkout'
alias gtagls='git describe --tags --abbrev=0'
alias gtag='git tag -s'
alias grst='git reset'
alias grst1='git reset HEAD^'
alias grst2='git reset HEAD^^'
alias grsth='git reset --hard'
alias grsth1='git reset --hard HEAD^'
alias grsth2='git reset --hard HEAD^^'
alias grsts='git reset --soft'
alias grsts1='git reset --soft HEAD^'
alias grsts2='git reset --soft HEAD^^'
alias gstash='git stash'
alias gstashls='git stash list'
alias grename='git mv --force'
gbranch() {
  # if given command `gbranch`
  # list out branches
  if [ $# = 0 ]; then
    echo 'printing branches'
    git branch
    return 0
  fi
  echo "creating branch '$1'"
  # given the command `gbranch berks-is-awesome`
  # creates a new branch `berks-is-awesome`
  # checks that branch out
  git checkout -b $1
  echo "creating '${2:-origin}/$1'"
  # this will make the current branch track origin/berks-is-awesome
  git push -u ${2:-origin} $1
}
gremote() {
  # gremote
  if [ $# == 0 ]; then
    echo "printing remote repositories"
    git remote -v
    return 0
  fi
  while test $# -gt 0; do
    case "$1" in
      -h|--help)
        echo "gremote - a better git remote"
        echo "gremote [options] [commands]"
        echo "options:"
        echo "-h, --help  list options and commands"
        echo "commands:"
        echo "add         gremote add remote-name url - Adds a new remote with url"
        echo "set         gremote set remote-name url - set or overwrite existing remote url"
        echo "remove      gremote remove remote-name  - remote remote repo"
        return 0
        ;;
      add)
        if [[ -z "${2//}" || "${#2}" -lt 3 ]]; then
          echo 'remote name must be atleast three characters'
          return 2
        fi
        # check if url is actual repo
        if ! git ls-remote --exit-code $3 &>/dev/null; then
          echo 'remote url does not resolve to proper git repo'
          return 2
        fi
        git remote add $2 $3
        echo "success"
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      set)
        # gremote set remote-name url
        # check if url is actual repo
        if ! git ls-remote --exit-code $3 &>/dev/null; then
          echo 'remote url does not resolve to proper git repo'
          return 2
        fi
        git remote set-url $2 $3
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      remove)
        # gremote remove remote-name
        echo "removing $2"
        git remote remove $2
        echo "remove successful"
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      *)
        echo "gremote: $1 is not a proper command"
        return 2
        ;;
    esac
  done
}
grebase() {
  # grebase
  if [ $# == 0 ]; then
    echo "grebase: Incorrect number of args"
    return 1
  fi

  if [ $1 == 'cont' ]; then
    echo "continuing..."
    git rebase --continue
    return 0
  fi

  if [ $1 == 'skip' ]; then
    echo "continuing..."
    git rebase --skip
    return 0
  fi
  git rebase $1
}
gclone() {
  # Will clone a repo into a new dir as the second arg
  git clone $1 $2
  # and it will cd into the newly created repo dir
  wd=$(pwd)
  echo "changing directory to $wd/${2:-$(basename $1 .git)}"
  cd ${2:-$(basename $1 .git)}
}
gpull() {
  # If given gpull upstream
  # find the current branch and pull that branch
  # from the `upstream` remote repository
  if [ $# = 1 ]; then
    currentbranch=$(git rev-parse --abbrev-ref HEAD)
    echo "current branch is $currentbranch"
    echo "pulling down branch '$currentbranch' from remote repository '$1'"
    git pull $1 $currentbranch
    return 0
  fi
  # Otherwise pull from the repository this branch is tracking
  git pull
}

gclean() {
  # will remove local merged refs
  # and delete those branches on the remote
  # can be used `glean` and will default to
  # the remote `origin` or can be used
  # `gclean upstream` to target specific
  # remotes
  currentbranch=$(git rev-parse --abbrev-ref HEAD)
  remote=${1:-origin}
  echo "current branch is '$currentbranch'"
  echo "pruning remote '$remote' refs that no longer"
  git remote prune $remote
  # List out the merged branches
  echo "deleting remote branches merged into '$currentbranch'"
  git branch -r --merged $currentbranch |\
    # filter out everything that has the same name as the current branch
    egrep -iv "$currentbranch" |\
    # grab only those of the current remote
    egrep -i "$remote/" |\
    # filter out remote name from the string
    sed "s/$remote\///g" |\
    # push and delete the branch
    xargs -n 1 git push --delete $remote
}

#Makes and CD's to a new directoy.
function mkncd() {
  mkdir -pv $1
  cd $_
}

# Node exports
# increases number of cores node-gyp uses when building
export JOBS=max

# bash completion w/ goodies
# brew install bash-completion
[ -f /usr/local/etc/bash_completion ] && . /usr/local/etc/bash_completion

# Git Completion to shortcuts
if [ -n "$(type -t __git_complete)" ] && [ "$(type -t __git_complete)" = function ]; then
  __git_complete gco _git_checkout
  __git_complete grebase _git_checkout
  # will autocomplete remotes
  __git_complete gpull __git_complete_remote_or_refspec
  __git_complete gclean __git_complete_remote_or_refspec
fi
# Fix <C-h> issue with neovim
# Not sure if this is sage to run more than once
# infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti && tic $TERM.ti

###-begin-npm-completion-###
#
# npm command completion script
if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
