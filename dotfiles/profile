# Add vi mappings to bash
set -o vi

[[ -s "$HOME/.private_aliases"  ]] && source "$HOME/.private_aliases"
# add fzf completion
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

export PATH=/usr/local/bin:$PATH

# Point to java 7
export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home"

# Adds mongoDB binaries to path
export PATH=$PATH:~/mongodb/bin

# Add RVM to PATH for scripting
export PATH=$PATH:$HOME/.rvm/bin

export GOPATH=$HOME/go/packages

#Heroku Toolbelt
export PATH=$PATH:/usr/local/heroku/bin

#PostgressApp commands
export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.3/bin

# Make neovim the default editor
export EDITOR=nvim
export VISUAL=$EDITOR

# Add lang settings for fonts to work properly
export LANG=en_US.UTF-8
export LC_COLLATE=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8
export LC_MESSAGES=en_US.UTF-8
export LC_MONETARY=en_US.UTF-8
export LC_NUMERIC=en_US.UTF-8
export LC_TIME=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Bash helper alias
## Starts MongoDB server
alias ..='cd ..'
alias ll='ls -aFlh'
alias v='nvim'
alias vi='nvim'
alias vim='nvim'
alias tmux="TERM=screen-256color-bce tmux -2"
## Will make parent directories if they don't exist
## Also verbose
alias mkdir="mkdir -pv"
alias whatismyip="curl http://ipecho.net/plain; echo"
## Make file executable
alias chmodx='chmod 755'
## Make file read/write-able
alias chmodrw='chmod 644'
## print bash function declaration in console
## Used to make sure profile changes are reflecting
alias echodec='declare -f'

lpasssearch() {
  lpass show -c --password $(lpass ls | fzf | awk '{print $(NF)}' | sed 's/\]//g')
}

#quick edits
alias vprofile='nvim ~/.profile'
alias sprofile='source ~/.profile'
alias vvimrc='nvim ~/.vimrc'
alias vneo='nvim ~/.config/nvim/init.vim'
alias vlint='nvim ~/.eslintrc'
alias vhyper='nvim ~/.hyper.js'

#node aliases
alias :mongo='mongod --dbpath ~/data/db'
alias npmig='sudo npm install -g'
alias npmug='sudo npm uninstall -g'
alias npmid='npm install --save-dev'
alias npmis='npm install --save'
alias npms='npm run start'
alias npmt='npm run test'
alias npml='npm run lint'

#quickmoves
alias cdnode='cd ~/node'
alias cdf='cd ~/node/freecodecamp/actual'
alias cdrt='cd ~/node/react'
alias cdrdx='cd ~/node/redux'
alias cdrwr='cd ~/node/rwr'
alias cdvim='cd ~/.vim'
alias cdsnippets='cd ~/.config/nvim/plugged/berkeleys-snippet-emporium'
cdfzf() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf +m) &&
    cd "$dir"
}

#git aliases
alias gstat='git status'
alias tstat='tig status'
alias gfetch='git fetch'
alias gpush='git push'
alias gpushntrack='git push -u'
alias gadd='git add'
alias gdiff='git diff | tig'
alias gcom='git cz'
alias gamend='git commit --amend'
alias glog='git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate'
alias glognum='git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --numstat'
alias gco='git checkout'
alias gtagls='git describe --tags --abbrev=0'
alias gtag='git tag -s'
alias grst='git reset'
alias grst1='git reset HEAD^'
alias grst2='git reset HEAD^^'
alias grsth='git reset --hard'
alias grsth1='git reset --hard HEAD^'
alias grsth2='git reset --hard HEAD^^'
alias grsts='git reset --soft'
alias grsts1='git reset --soft HEAD^'
alias grsts2='git reset --soft HEAD^^'
alias gstash='fstash'
alias grename='git mv --force'
fbranch() {
  # fbranch
  # search for branch using fuzzy search
  local branches branch
  branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
    branch=$(echo "$branches" | fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
    git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}
fco() {
  # fco - checkout git branch/tag with fzf search
  local tags branches target
  tags=$(
  git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
  branches=$(
  git branch --all | grep -v HEAD             |
  sed "s/.* //"    | sed "s#remotes/[^/]*/##" |
  sort -u          | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
  target=$(
  (echo "$tags"; echo "$branches") |
  fzf-tmux -l30 -- --no-hscroll --ansi +m -d "\t" -n 2) || return
  git checkout $(echo "$target" | awk '{print $2}')
}
fshow() {
  # fshow - git commit browser
  git log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute: (grep -o '[a-f0-9]\{7\}' | head -1 | xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF' {} FZF-EOF"
}
fcs() {
  # fcs - get git commit sha
  # example usage: git rebase -i `fcs`
  local commits commit
  commits=$(git log --color=always --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse) &&
  echo -n $(echo "$commit" | sed "s/ .*//")
}
fstash() {
  # fstash - easier way to deal with stashes
  # type fstash to get a list of your stashes
  # enter shows you the contents of the stash
  # ctrl-d shows a diff of the stash against your current HEAD
  # ctrl-b checks the stash out as a branch, for easier merging
  local i arr out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    # below is equivalent to 'mapfile -t out <<< "$out"'
    i=0
    while IFS=$'\n' read -r line
    do
      arr[i]="$line"
      i=$((i + 1))
    done <<< "$out"

    q="${arr[0]}"
    k="${arr[1]}"
    sha="${arr[ ${#arr[@]} - 1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}
gcor() {
  # gcor feat/foo
  # = git checkout -b origin feat/foo
  # gcor feat/foo upstream
  git fetch ${2:-origin}
  git checkout -b $1 ${2:-origin}/$1
}
gpr() {
  # gpr 123  upstream
  # gpr 124
  remote=origin
  branchname=origin/$1
  if [ $# = 2 ]; then
    branchname=$2/$1
    remote=$2
  fi
  echo "fetching PR #'$1' from '$branchname'"
  git fetch $remote pull/$1/head:$branchname
  git checkout $branchname
}
gbranch() {
  # if given command `gbranch`
  # list out branches
  if [ $# = 0 ]; then
    fbranch
    return 0
  fi
  echo "creating branch '$1'"
  # given the command `gbranch berks-is-awesome`
  # creates a new branch `berks-is-awesome`
  # checks that branch out
  git checkout -b $1
  echo "creating '${2:-origin}/$1'"
  # this will make the current branch track origin/berks-is-awesome
  git push -u ${2:-origin} $1
}
gremote() {
  # gremote
  if [ $# == 0 ]; then
    echo "printing remote repositories"
    git remote -v
    return 0
  fi
  while test $# -gt 0; do
    case "$1" in
      -h|--help)
        echo "gremote - a better git remote"
        echo "gremote [options] [commands]"
        echo "options:"
        echo "-h, --help  list options and commands"
        echo "commands:"
        echo "add         gremote add remote-name url - Adds a new remote with url"
        echo "set         gremote set remote-name url - set or overwrite existing remote url"
        echo "remove      gremote remove remote-name  - remote remote repo"
        return 0
        ;;
      add)
        if [[ -z "${2//}" || "${#2}" -lt 3 ]]; then
          echo 'remote name must be atleast three characters'
          return 2
        fi
        # check if url is actual repo
        if ! git ls-remote --exit-code $3 &>/dev/null; then
          echo 'remote url does not resolve to proper git repo'
          return 2
        fi
        git remote add $2 $3
        echo "success"
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      set)
        # gremote set remote-name url
        # check if url is actual repo
        if ! git ls-remote --exit-code $3 &>/dev/null; then
          echo 'remote url does not resolve to proper git repo'
          return 2
        fi
        git remote set-url $2 $3
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      remove)
        # gremote remove remote-name
        echo "removing $2"
        git remote remove $2
        echo "remove successful"
        echo "printing remote repositories"
        git remote -v
        return 0
        ;;
      *)
        echo "gremote: $1 is not a proper command"
        return 2
        ;;
    esac
  done
}
grebase() {
  # grebase
  if [ $# == 0 ]; then
    echo "grebase: Incorrect number of args"
    return 1
  fi

  if [ $1 == 'cont' ]; then
    echo "continuing..."
    git rebase --continue
    return 0
  fi

  if [ $1 == 'skip' ]; then
    echo "continuing..."
    git rebase --skip
    return 0
  fi
  git rebase $1
}
gclone() {
  # Will clone a repo into a new dir as the second arg
  git clone $1 $2
  # and it will cd into the newly created repo dir
  wd=$(pwd)
  echo "changing directory to $wd/${2:-$(basename $1 .git)}"
  cd ${2:-$(basename $1 .git)}
}
gpull() {
  # If given gpull upstream
  # find the current branch and pull that branch
  # from the `upstream` remote repository
  if [ $# = 1 ]; then
    currentbranch=$(git rev-parse --abbrev-ref HEAD)
    echo "current branch is $currentbranch"
    echo "pulling down branch '$currentbranch' from remote repository '$1'"
    git pull $1 $currentbranch
    return 0
  fi
  # Otherwise pull from the repository this branch is tracking
  git pull
}

gclean() {
  # will remove local merged refs
  # and delete those branches on the remote
  # can be used `glean` and will default to
  # the remote `origin` or can be used
  # `gclean upstream` to target specific
  # remotes
  currentbranch=$(git rev-parse --abbrev-ref HEAD)
  remote=${1:-origin}
  echo "current branch is '$currentbranch'"
  echo "pruning remote '$remote' refs that no longer"
  git remote prune $remote
  # List out the merged branches
  echo "deleting remote branches merged into '$currentbranch'"
  git branch -r --merged $currentbranch |\
    # filter out everything that has the same name as the current branch
    egrep -iv "$currentbranch" |\
    # grab only those of the current remote
    egrep -i "$remote/" |\
    # filter out remote name from the string
    sed "s/$remote\///g" |\
    # push and delete the branch
    xargs -n 1 git push --delete $remote
}

#Makes and CD's to a new directoy.
function mkncd() {
  mkdir -pv $1
  cd $_
}

# Node exports
# increases number of cores node-gyp uses when building
export JOBS=max

# bash completion w/ goodies
# brew install bash-completion
[ -f /usr/local/etc/bash_completion ] && . /usr/local/etc/bash_completion

# Git Completion to shortcuts
if [ -n "$(type -t __git_complete)" ] && [ "$(type -t __git_complete)" = function ]; then
  __git_complete gco _git_checkout
  __git_complete grebase _git_checkout
  # will autocomplete remotes
  __git_complete gpull __git_complete_remote_or_refspec
  __git_complete gclean __git_complete_remote_or_refspec
fi
# Fix <C-h> issue with neovim
# Not sure if this is sage to run more than once
# infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti && tic $TERM.ti

###-begin-npm-completion-###
#
# npm command completion script
if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###

###
# npm publish
# install prerequisites:
npmpublishpre() {
  sudo npm install -g
    trash \
    commitizen \
    cz-freecodecamp \
    conventional-recommended-bump \
    conventional-changelog-cli \
    conventional-github-releaser \
    conventional-commits-detector \
    json
}
# `npmpublish` with optional argument `patch`/`minor`/`major`/`<version>`
# defaults to conventional-recommended-bump
# and optional argument preset `angular`/ `jquery` ...
# defaults to conventional-commits-detector
npmpublish() {
  # travis status --no-interactive &&
  # start with fresh npm install
  trash node_modules &>/dev/null;
  # should almost always be angular
  preset=${2:-$(conventional-commits-detector)}
  bump=${1:-$(conventional-recommended-bump -p $preset)}
  echo "Bump: $bump."
  echo "Preset: $preset"
  echo "Do you wish to continue?"
  select yn in "Yes" "No"; do
    case $yn in
      No ) return 0;;
    esac
  done
  # make sure we have the latest commits
  git pull --rebase &&
    # get fresh packages
    npm install &&
    # make sure tests pass
    npm test &&
    # copy package.json for later restoration
    cp package.json _package.json &&
    # copy package-lock if exists
    [[ -e package-lock.json ]] && cp package-lock.json _package-lock.json || echo "info: no package-lock found" &&
    npm --no-git-tag-version version $bump &>/dev/null &&
    echo "creating/updating changelong" &&
    conventional-changelog -i CHANGELOG.md -s -p $preset &&
    git add CHANGELOG.md &&
    version=`cat package.json | json version` &&
    echo "Adding changelog" &&
    git commit -m "docs(CHANGELOG): v$version" &&
    mv -f _package.json package.json &&
    [[ -e _package.json ]] && mv -f _package-lock.json package-lock.json ||
    echo "cutting release" &&
    npm version $bump -m "chore(release): %s" &&
    echo "pushing up changes" &&
    git push --follow-tags &&
    echo "creating github release" &&
    conventional-github-releaser -p $preset &&
    echo "publishing to npm" &&
    npm publish
}
